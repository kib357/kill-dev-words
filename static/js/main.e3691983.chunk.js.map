{"version":3,"sources":["Word.ts","Game.ts","GameScreen.tsx","App.tsx","index.tsx"],"names":["Word","GAME_STATE","word","timestamp","pos","duration","isTyped","id","Math","floor","random","_word","setWord","newWord","setTyped","getWord","getTyped","isKilled","length","getTypedWord","words","find","sortByClosest","a","b","aTransitionLeft","bTransitionLeft","Game","WORDS","PLAYER_OFFSET","start_timestamp","Date","now","game_duration","state","PLAY","score","_score","addScore","scoreUp","particles","wordSpawnTimeout","getRandomDuration","spawnWord","timeout","generateSpawnTimeout","index","getRandomWord","push","getDuration","shootParticle","document","getElementById","clientWidth","clientHeight","progress","start","destinationPos","x","y","particle","key","String","destination","getParticles","onKeydown","e","char","code","toLowerCase","replace","typedWord","newTyped","sort","indexOf","findClosestWord","getState","current","tick","killed","Boolean","countScore","isCollision","detectWordCollision","getTimeIsUp","SCORE","filter","killWords","isFiltered","filtered","cleanParticles","Score","React","memo","value","decimals","speed","ease","customFunctionRender","n","toString","Particle","offsetHeight","offsetWidth","containerHeight","containerWidth","map","bounce","keyframes","className","css","animation","position","bottom","left","transform","width","height","background","animationTimingFunction","low1","high1","low2","high2","GameScreen","props","Words","useMemo","typed","substr","cursor","notTyped","steps","style","zIndex","transitionDuration","animationDuration","transitionTimingFunction","Particles","marginLeft","minWidth","display","lib","1","split","2","3","4","5","6","authors","Object","values","flat","Lib","App","useState","gameLoopId","setGameLoopId","setState","game","handleKeyDown","useCallback","myCanvas","myConfetti","confetti","create","resize","end","lookPos","particleCount","spread","startVelocity","ticks","gravity","colors","shapes","origin","shootConfetti","console","log","useEffect","addEventListener","interval","setInterval","clearInterval","removeEventListener","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e3691983.chunk.js","sourcesContent":["export interface IWord {\n  timestamp: number;\n  pos: number;\n  word?: string;\n  duration: number;\n  isTyped?: number;\n}\n\nexport interface IWordObject extends IWord {\n  getWord: () => string;\n  setWord: (word: string) => void;\n  getTyped: () => number;\n  setTyped: () => void;\n  id: number;\n  isKilled: () => boolean;\n}\n\nfunction Word(\n  { word = \"\", timestamp, pos, duration, isTyped = 0 }: IWord,\n  level = 0\n): IWordObject {\n  let id = Math.floor(Math.random() * 10000);\n  let _word = word;\n  // const timestamp = Date.now();\n  const getRandomX = () => {\n    return 0;\n    // max 100\n  };\n  const getRandomDuration = () => Math.random() * 100;\n  // const pos = getRandomX();\n  // const duration = getRandomDuration();\n  const setWord = (newWord: string) => (_word = newWord);\n  const setTyped = () => isTyped++;\n\n  return {\n    timestamp,\n    pos,\n    id,\n    getWord: () => _word,\n    getTyped: () => isTyped,\n    setTyped,\n    duration,\n    setWord,\n    isKilled: () => _word.length === isTyped,\n  };\n}\n\nexport default Word;\n","import Word, { IWord, IWordObject } from \"./Word\";\n\ninterface IGame {\n  duration?: number;\n  WORDS?: string[];\n  PLAYER_OFFSET: number;\n}\nexport type IDestination = { x: number; y: number };\n\nexport interface IParticle {\n  duration: number;\n  destination: IDestination;\n  key: string;\n  timestamp: number;\n}\n\nexport interface IGameState {\n  state: GAME_STATE;\n  score: number;\n  game_duration: number;\n  words: IWordObject[];\n  getParticles: () => IParticle[];\n  current?: IWordObject;\n}\n\nexport enum GAME_STATE {\n  PLAY,\n  SCORE,\n}\n\nfunction Game({ duration = 30 * 1000, WORDS = [], PLAYER_OFFSET }: IGame) {\n  const start_timestamp = Date.now();\n  let game_duration = 0;\n  let state: GAME_STATE = GAME_STATE.PLAY;\n  const stopGame = () => {\n    state = GAME_STATE.SCORE;\n    game_duration = getDuration();\n  };\n\n  let score = 0;\n  let _score = 0;\n  const addScore = (word: IWordObject) => {\n    const scoreUp = word.getWord().length;\n    _score += scoreUp * 123; // TODO рефакторинг двух видов счета (внутренний=100 и внешний = 123 * длинна слова)\n    score += 100;\n  };\n\n  let particles: IParticle[] = [];\n\n  let words: IWordObject[] = [];\n  let wordSpawnTimeout = 0;\n  const getRandomDuration = (word: string) => {\n    const duration = Math.floor(\n      3000 + word.length * (500 + Math.random() * 500)\n    );\n    const levelMultiplier = score >= 200 ? 1 / (score / 200) : 1;\n\n    return duration * levelMultiplier;\n  };\n\n  const getRandomWord = () => {\n    const index = Math.floor(Math.random() * WORDS?.length);\n    return WORDS[index];\n  };\n  const getRandomPos = () => Math.floor(Math.random() * 100);\n  const spawnWord = () => {\n    const now = Date.now();\n    if (wordSpawnTimeout <= now) {\n      wordSpawnTimeout = generateSpawnTimeout();\n      const word = getRandomWord();\n      words.push(\n        Word({\n          word,\n          pos: getRandomPos(),\n          timestamp: Date.now(),\n          duration: getRandomDuration(word),\n        })\n      );\n    }\n  };\n\n  const getTimeIsUp = () => {\n    const now = Date.now();\n    return start_timestamp + duration <= now;\n  };\n\n  const getDuration = () => Date.now() - start_timestamp;\n\n  // PARTICLES\n  // TODO TESTS\n  const shootParticle = (word: IWordObject) => {\n    const PARTICLE_DURATION = 180;\n    const particlesContainer = document.getElementById(\n      \"particles\"\n    ) as HTMLElement | null;\n    const { clientWidth = 0, clientHeight = 0 } = particlesContainer || {};\n    const now = Date.now();\n    const { pos, duration, timestamp } = word;\n    const currentPos = duration - (now - timestamp + PARTICLE_DURATION);\n    const progress = 1 - (duration - currentPos) / duration;\n\n    // from x: 10%, y: 100%\n    const start = {\n      x: pos / 100,\n      y: 0,\n    };\n    // to x: 50%, y: 0% - PLAYER_OFFSET\n    const end = {\n      x: 0.5,\n      y: (clientHeight - PLAYER_OFFSET) / clientHeight,\n    };\n\n    // word current position\n    const destinationPos = {\n      x: start.x + (end.x - start.x) * (1 - progress),\n      y: start.y + (end.y - start.y) * (1 - progress),\n    };\n\n    const particle = {\n      timestamp: Date.now(),\n      key: String(Math.random() * 10000),\n      destination: destinationPos,\n      duration: PARTICLE_DURATION,\n    };\n    particles = [...particles, particle];\n  };\n  const getParticles = () => particles;\n\n  //  TODO TESTS\n  const cleanParticles = () => {\n    let isFiltered = false;\n    const now = Date.now(); // TODO refactor to global now value\n    const filtered = particles.filter(({ timestamp, duration }) => {\n      if (timestamp + duration < now) {\n        isFiltered = true;\n        return false;\n      }\n\n      return true;\n    });\n\n    if (isFiltered) {\n      particles = filtered;\n    }\n  };\n\n  return {\n    onKeydown: (e: { key: string; code: string }) => {\n      const prepareCode = (code: string) =>\n        code.toLowerCase().replace(\"key\", \"\");\n      const char = prepareCode(e.code);\n      const typedWord = getTypedWord(words);\n      if (typedWord) {\n        const word = typedWord.getWord();\n        const isCorrect = word[typedWord?.getTyped()] === char;\n        if (isCorrect) {\n          typedWord.setTyped();\n          shootParticle(typedWord);\n          return typedWord;\n        }\n      } else {\n        const newTyped = findClosestWord(words, char);\n        newTyped?.setTyped();\n        newTyped && shootParticle(newTyped);\n        return newTyped;\n      }\n\n      return null;\n    },\n    getState: (): IGameState => {\n      return {\n        state,\n        score: _score,\n        game_duration,\n        words,\n        getParticles,\n        current: getTypedWord(words),\n      };\n    },\n    tick: () => {\n      const { score, killed } = countScore(words);\n      if (score && killed) addScore(killed);\n\n      const collision = detectWordCollision(words);\n      if (collision || getTimeIsUp()) {\n        stopGame();\n      } else {\n        words = killWords(words);\n        spawnWord();\n      }\n\n      cleanParticles();\n    },\n  };\n}\n\nexport function getTypedWord(words: IWordObject[]) {\n  return words.find((word) => word.getTyped());\n}\n\nexport function generateSpawnTimeout() {\n  // TODO:GAMEPLAY use level\n  const now = Date.now();\n  const timeout = Math.floor(2000 + Math.random() * 2000);\n  return now + timeout;\n}\n\nexport function sortByClosest(a: IWord, b: IWord) {\n  const { timestamp: timestampA, duration: durationA } = a;\n  const { timestamp: timestampB, duration: durationB } = b;\n  const aTransitionLeft = timestampA + durationA;\n  const bTransitionLeft = timestampB + durationB;\n  if (aTransitionLeft < bTransitionLeft) {\n    return -1;\n  } else if (aTransitionLeft === bTransitionLeft) {\n    return 0;\n  }\n  return 1;\n}\n\nexport function findClosestWord(\n  words: IWordObject[],\n  char: string\n): IWordObject | null {\n  return (\n    words\n      .sort(sortByClosest)\n      .find(({ getWord }) => getWord().indexOf(char) === 0) || null\n  );\n}\n\nfunction isKilled(word: IWordObject) {\n  return word.isKilled();\n}\n\nexport function killWords(words: IWordObject[]): IWordObject[] {\n  return words.filter((word) => !isKilled(word));\n}\n\nexport function countScore(words: IWordObject[]): {\n  score: boolean;\n  killed: IWordObject | undefined;\n} {\n  const killed = words.find(isKilled);\n  return { score: Boolean(killed), killed };\n}\n\nexport function detectWordCollision(words: IWordObject[]): boolean {\n  const isCollision = ({ duration, timestamp }: IWordObject) => {\n    const now = Date.now();\n    return timestamp + duration <= now;\n  };\n  return Boolean(words.find(isCollision));\n}\n\nexport default Game;\n","import React from \"react\";\nimport { IGameState } from \"./Game\";\nimport NumberEasing from \"react-number-easing\";\nimport { keyframes } from \"@emotion/react\";\nimport { css } from \"@emotion/css\";\n\nfunction GameScreen(props: { state: IGameState | null }) {\n  const { state } = props;\n  const Words = React.useMemo(\n    () =>\n      state?.words.map((word) => {\n        const { duration } = word;\n        const _word = word.getWord();\n        const typed = _word.substr(0, word.getTyped());\n        const cursor = typed ? _word.substr(word.getTyped(), 1) : null;\n        const notTyped = _word.substr(\n          typed ? word.getTyped() + 1 : word.getTyped()\n        );\n\n        // duration min 500 max 10000\n        // 6000 - 60\n        const steps = Math.floor(duration / 110);\n\n        return (\n          <div\n            key={word.id}\n            className={`word toEnd eightBit`}\n            style={{\n              zIndex: cursor ? 2 : 1,\n              left: word.pos + \"%\",\n              transitionDuration: `${duration}ms`,\n              animationDuration: `${duration}ms`,\n              animationTimingFunction: `steps(${steps}, end)`,\n              transitionTimingFunction: `steps(${steps}, end)`,\n            }}\n          >\n            <span className=\"outlined_inverted\">{typed}</span>\n            {cursor ? <span className=\"cursor\">{cursor}</span> : null}\n            <span>{notTyped}</span>\n          </div>\n        );\n      }),\n    [state?.words || []]\n  );\n  const particles = state?.getParticles() || [];\n  const Particles = React.useMemo(\n    () => particles.map((particle) => <Particle {...particle} />),\n    [particles || []]\n  );\n\n  return (\n    <div className=\"game\">\n      <div className=\"deadline\">\n        <span className=\"outlined\">DEADLINE</span>\n        <span style={{ marginLeft: \"0.2em\" }}>&nbsp;1:59</span>\n      </div>\n      <div className=\"container\">\n        <div className=\"logo\"></div>\n        <div className=\"viewport\">\n          <div className=\"words\">{Words}</div>\n          <div className=\"particles\" id=\"particles\">\n            {Particles}\n          </div>\n          <canvas\n            style={{ width: \"100%\", height: \"100%\" }}\n            id=\"fireworks\"\n          ></canvas>\n          <div className=\"player\"></div>\n        </div>\n        <div className=\"desktop\"></div>\n      </div>\n      <div className=\"sidebar\">\n        <div className=\"score\">\n          <span className=\"outlined\">SCORE</span>\n          <span\n            style={{\n              marginLeft: \"0.2em\",\n              minWidth: \"4em\",\n              display: \"inline-block\",\n            }}\n          >\n            &nbsp;\n            <Score key=\"score-wrapper\" value={state?.score} />\n          </span>\n        </div>\n        <div className=\"typed-char outlined\">T</div>\n      </div>\n    </div>\n  );\n}\n\ninterface IScore {\n  value?: number;\n}\nconst Score: React.FC<IScore> = React.memo(({ value = 0 }) => {\n  const format = (n: number) => numberWithSpaces(Math.floor(n));\n  return (\n    <NumberEasing\n      decimals={0}\n      speed={1000}\n      key=\"score\"\n      ease=\"cubicIn\"\n      value={value}\n      customFunctionRender={format}\n    />\n  );\n});\n\nfunction numberWithSpaces(x: number) {\n  return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n}\n\ninterface IParticle {\n  destination: { x: number; y: number };\n  duration: number;\n  key: string;\n}\nfunction Particle({ destination, duration, key }: IParticle) {\n  const container = document.getElementById(\"particles\");\n  const { offsetHeight: containerHeight, offsetWidth: containerWidth } =\n    container || {\n      offsetHeight: 1,\n      offsetWidth: 1,\n    };\n  const x = map(destination.x, 0, 1, -containerWidth / 2, containerWidth / 2);\n  const y = map(destination.y, 0, 1, -containerHeight, 0);\n\n  const bounce = keyframes`\n  from, {\n    transform: translate3d(0, 0, 0);\n  }\n\n  to {\n    transform: translate3d(${x}px, ${y}px,0);\n  }\n`;\n\n  return (\n    <div\n      key={key}\n      className={css({\n        animation: `${bounce} ${duration}ms ease infinite`,\n        position: \"absolute\",\n        bottom: \"calc(45px - (9px / 2))\",\n        left: \"calc(50% - (9px / 2))\",\n        transform: \"translate(0, 0)\",\n        width: \"9px\",\n        height: \"9px\",\n        background: \"white\",\n        animationTimingFunction: `steps(${Math.floor(duration / 30)}, end)`,\n      })}\n    ></div>\n  );\n}\nfunction map(\n  value: number,\n  low1: number,\n  high1: number,\n  low2: number,\n  high2: number\n) {\n  return low2 + ((high2 - low2) * (value - low1)) / (high1 - low1);\n}\n\nexport default GameScreen;\n","import React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport Game, { GAME_STATE, IGameState } from \"./Game\";\nimport confetti, { shape } from \"canvas-confetti\";\nimport GameScreen from \"./GameScreen\";\nimport { IWordObject } from \"./Word\";\n\nconst PLAYER_OFFSET = 65;\nconst shootConfetti = (word: IWordObject) => {\n  const myCanvas = document.getElementById(\n    \"fireworks\"\n  ) as HTMLCanvasElement | null;\n  var myConfetti = myCanvas\n    ? confetti.create(myCanvas, { resize: true })\n    : confetti;\n  function randomInRange(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n  }\n  const now = Date.now();\n  const { pos, duration, timestamp } = word;\n  const currentPos = duration - (now - timestamp);\n  const progress = 1 - (duration - currentPos) / duration;\n\n  if (myCanvas) {\n    // from x: 10%, y: 100%\n    const start = {\n      x: pos / 100,\n      y: 0,\n    };\n    // to x: 50%, y: 0% - PLAYER_OFFSET\n    const end = {\n      x: 0.5,\n      y: (myCanvas.clientHeight - PLAYER_OFFSET) / myCanvas.clientHeight,\n    };\n\n    // word current position\n    const lookPos = {\n      x: start.x + (end.x - start.x) * (1 - progress),\n      y: start.y + (end.y - start.y) * (1 - progress),\n    };\n\n    const look = {\n      particleCount: 5 + Math.random() * 10,\n      spread: 220,\n      startVelocity: 10,\n      ticks: 35,\n      gravity: 0.5,\n      colors: [\"#ffffff\"],\n      shapes: [\"square\"] as shape[],\n      origin: {\n        x: lookPos.x,\n        // since they fall down, start a bit higher than random\n        y: lookPos.y,\n      },\n    };\n\n    myConfetti(look);\n  } else {\n    const look = {\n      particleCount: 10,\n      spread: 220,\n      startVelocity: 10,\n      ticks: 40,\n      gravity: 0.4,\n      colors: [\"#ffffff\"],\n      shapes: [\"square\"] as shape[],\n      origin: {\n        x: Math.random(),\n        // since they fall down, start a bit higher than random\n        y: Math.random() - 0.2,\n      },\n    };\n\n    myConfetti(look);\n  }\n};\n\nconst FPS = 30;\n\nconst WORDS = Lib();\n\nfunction App() {\n  const [gameLoopId, setGameLoopId] = useState<NodeJS.Timeout | null>(null);\n  const [state, setState] = useState<IGameState | null>(null);\n  const game = React.useMemo(() => Game({ WORDS, PLAYER_OFFSET }), []);\n  const handleKeyDown = React.useCallback(({ key, code }: KeyboardEvent) => {\n    const word = game.onKeydown({ key, code });\n    if (word) {\n      word.isKilled() && shootConfetti(word);\n    } else {\n      console.log(\"miss\");\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleKeyDown);\n    const tick = () => {\n      game.tick();\n      setState(game.getState());\n    };\n\n    tick();\n    const interval = setInterval(tick, 1000 / FPS);\n    setGameLoopId(interval);\n\n    return () => {\n      clearInterval(interval);\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (state?.state === GAME_STATE.SCORE) {\n      console.log(\"SCORE SCREEN\");\n      gameLoopId && clearInterval(gameLoopId);\n      setGameLoopId(null);\n    } else if (state?.state === GAME_STATE.PLAY) {\n      console.log(\"PLAY SCREEN\");\n    }\n  }, [state?.state]);\n\n  return (\n    <div className=\"App\">\n      <GameScreen state={state} />\n      {/* <div className=\"words\">\n        {state?.words.map((word) => {\n          const { duration } = word;\n          const _word = word.getWord();\n          const typed = _word.substr(0, word.getTyped());\n          const notTyped = _word.substr(word.getTyped());\n\n          return (\n            <div\n              key={word.id}\n              className={`word toEnd`}\n              style={{\n                left: word.pos + \"%\",\n                transitionDuration: `${duration}ms`,\n                animationDuration: `${duration}ms`,\n                animationTimingFunction: \"steps(100, end)\",\n                transitionTimingFunction: \"steps(100, end)\",\n                background: notTyped.length === 0 ? \"green\" : undefined,\n              }}\n            >\n              <span style={{ color: \"orange\", fontWeight: \"bold\" }}>\n                {typed}\n              </span>\n              {notTyped}\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"player\"></div> */}\n    </div>\n  );\n}\n\nfunction Lib() {\n  // TODO добавить смешные слова, слова мемы программистов\n  var lib = {\n    1: \"nil lib go pen var if add zsh run php bug fix api key add all id em erb rem px ux ui svg for box git xml rtc pre rgb hsl rel web js def moz end to dev css\".split(\n      \" \"\n    ),\n    2: \"void null code scss bash else push edge ruby pull tidy head body foot haml slim jade true html color top span left right save fork flex none bold auto href link size ease fill path rgba hsla from skew sort font size team sass hash json less attr text data\".split(\n      \" \"\n    ),\n    3: \"react ember event width height clone gulp concat fetch valid aside style elsif babel jquery param start assign posts logos chrome blogs block align xcode slack class agile xmlns origin comma scrum stroke scale false rails\".split(\n      \" \"\n    ),\n    4: \"inline method deploy target assign window grunt commit minify jekyll stylus article import tweets google opacity weight bottom scroll italic profile hidden github keytrap editor webkit string number integer decimal period jsconf\".split(\n      \" \"\n    ),\n    5: \"inherit function includes bourbon normalize angular explorer section ternary twitter overflow absolute postcss invalid viewbox content sublime session display background compile bracket backbone boolean codepen dreamhire contains standup\".split(\n      \" \"\n    ),\n    6: \"chriscoyier javascript cssdevconf customers autoprefixer stackoverflow visibility headphones underscore bootstrap csstricks typescript livescript customer settings semicolon attribute parenthesis markdown compiler responsive preprocessor webdesign developer development\".split(\n      \" \"\n    ),\n    authors: \"gary petr anna sergey manychat\".split(\" \"),\n  };\n  return Object.values(lib).flat();\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}