{"version":3,"sources":["Word.ts","Game.ts","App.tsx","index.tsx"],"names":["Word","GAME_STATE","word","timestamp","pos","duration","isTyped","id","Math","floor","random","_word","setWord","newWord","setTyped","getWord","getTyped","isKilled","length","getTypedWord","words","find","sortByClosest","a","b","aTransitionLeft","bTransitionLeft","Game","WORDS","start_timestamp","Date","now","game_duration","state","PLAY","score","addScore","wordSpawnTimeout","getRandomDuration","spawnWord","timeout","generateSpawnTimeout","index","getRandomWord","push","getDuration","onKeydown","e","char","key","typedWord","newTyped","sort","indexOf","findClosestWord","getState","current","tick","Boolean","countScore","isCollision","detectWordCollision","getTimeIsUp","SCORE","filter","killWords","lib","1","split","2","3","4","5","6","Object","values","flat","Lib","App","useState","gameLoopId","setGameLoopId","setState","game","React","useMemo","handleKeyDown","useCallback","code","randomInRange","min","max","confetti","angle","spread","particleCount","origin","y","shootConfetti","console","log","useEffect","document","addEventListener","interval","setInterval","clearInterval","removeEventListener","className","map","typed","substr","notTyped","style","left","transitionDuration","animationDuration","background","undefined","color","fontWeight","position","top","textAlign","transform","toFixed","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.67a5c6f9.chunk.js","sourcesContent":["export interface IWord {\n  timestamp: number;\n  pos: number;\n  word?: string;\n  duration: number;\n  isTyped?: number;\n}\n\nexport interface IWordObject extends IWord {\n  getWord: () => string;\n  setWord: (word: string) => void;\n  getTyped: () => number;\n  setTyped: () => void;\n  id: number;\n  isKilled: () => boolean;\n}\n\nfunction Word(\n  { word = \"\", timestamp, pos, duration, isTyped = 0 }: IWord,\n  level = 0\n): IWordObject {\n  let id = Math.floor(Math.random() * 10000);\n  let _word = word;\n  // const timestamp = Date.now();\n  const getRandomX = () => {\n    return 0;\n    // max 100\n  };\n  const getRandomDuration = () => Math.random() * 100;\n  // const pos = getRandomX();\n  // const duration = getRandomDuration();\n  const setWord = (newWord: string) => (_word = newWord);\n  const setTyped = () => isTyped++;\n\n  return {\n    timestamp,\n    pos,\n    id,\n    getWord: () => _word,\n    getTyped: () => isTyped,\n    setTyped,\n    duration,\n    setWord,\n    isKilled: () => _word.length === isTyped,\n  };\n}\n\nexport default Word;\n","import Word, { IWord, IWordObject } from \"./Word\";\n\ninterface IGame {\n  duration?: number;\n  WORDS?: string[];\n}\n\nexport interface IGameState {\n  state: GAME_STATE;\n  score: number;\n  game_duration: number;\n  words: IWordObject[];\n  current?: IWordObject;\n}\n\nexport enum GAME_STATE {\n  PLAY,\n  SCORE,\n}\n\nfunction Game({ duration = 30 * 1000, WORDS = [] }: IGame) {\n  const start_timestamp = Date.now();\n  let game_duration = 0;\n  let state: GAME_STATE = GAME_STATE.PLAY;\n  const stopGame = () => {\n    state = GAME_STATE.SCORE;\n    game_duration = getDuration();\n  };\n\n  let score = 0;\n  const addScore = () => (score += 100);\n\n  let words: IWordObject[] = [];\n  let wordSpawnTimeout = 0;\n  const getRandomDuration = (word: string) => {\n    const duration = Math.floor(\n      3000 + word.length * (500 + Math.random() * 500)\n    );\n    const levelMultiplier = score >= 200 ? 1 / (score / 200) : 1;\n\n    return duration * levelMultiplier;\n  };\n\n  const getRandomWord = () => {\n    const index = Math.floor(Math.random() * WORDS?.length);\n    return WORDS[index];\n  };\n  const getRandomPos = () => Math.floor(Math.random() * 100);\n  const spawnWord = () => {\n    const now = Date.now();\n    if (wordSpawnTimeout <= now) {\n      wordSpawnTimeout = generateSpawnTimeout();\n      const word = getRandomWord();\n      words.push(\n        Word({\n          word,\n          pos: getRandomPos(),\n          timestamp: Date.now(),\n          duration: getRandomDuration(word),\n        })\n      );\n    }\n  };\n\n  const getTimeIsUp = () => {\n    const now = Date.now();\n    return start_timestamp + duration <= now;\n  };\n\n  const getDuration = () => Date.now() - start_timestamp;\n\n  return {\n    onKeydown: (e: { key: string; code: string }) => {\n      const char = e.key;\n      const typedWord = getTypedWord(words);\n      if (typedWord) {\n        const word = typedWord.getWord();\n        const isCorrect = word[typedWord?.getTyped()] === char;\n        if (isCorrect) {\n          typedWord.setTyped();\n          return typedWord;\n        }\n      } else {\n        const newTyped = findClosestWord(words, char);\n        newTyped?.setTyped();\n        return newTyped;\n      }\n\n      return null;\n    },\n    getState: (): IGameState => {\n      return {\n        state,\n        score,\n        game_duration,\n        words,\n        current: getTypedWord(words),\n      };\n    },\n    tick: () => {\n      const score = countScore(words);\n      if (score) addScore();\n\n      const collision = detectWordCollision(words);\n      if (collision || getTimeIsUp()) {\n        stopGame();\n      } else {\n        words = killWords(words);\n        spawnWord();\n      }\n    },\n  };\n}\n\nexport function getTypedWord(words: IWordObject[]) {\n  return words.find((word) => word.getTyped());\n}\n\nexport function generateSpawnTimeout() {\n  // TODO use level\n  const now = Date.now();\n  const timeout = Math.floor(2000 + Math.random() * 2000);\n  return now + timeout;\n}\n\nexport function sortByClosest(a: IWord, b: IWord) {\n  const { timestamp: timestampA, duration: durationA } = a;\n  const { timestamp: timestampB, duration: durationB } = b;\n  const aTransitionLeft = timestampA + durationA;\n  const bTransitionLeft = timestampB + durationB;\n  if (aTransitionLeft < bTransitionLeft) {\n    return -1;\n  } else if (aTransitionLeft === bTransitionLeft) {\n    return 0;\n  }\n  return 1;\n}\n\nexport function findClosestWord(\n  words: IWordObject[],\n  char: string\n): IWordObject | null {\n  return (\n    words\n      .sort(sortByClosest)\n      .find(({ getWord }) => getWord().indexOf(char) === 0) || null\n  );\n}\n\nfunction isKilled(word: IWordObject) {\n  return word.isKilled();\n}\n\nexport function killWords(words: IWordObject[]): IWordObject[] {\n  return words.filter((word) => !isKilled(word));\n}\n\nexport function countScore(words: IWordObject[]): boolean {\n  return Boolean(words.find(isKilled));\n}\n\nexport function detectWordCollision(words: IWordObject[]): boolean {\n  const isCollision = ({ duration, timestamp }: IWordObject) => {\n    const now = Date.now();\n    return timestamp + duration <= now;\n  };\n  return Boolean(words.find(isCollision));\n}\n\nexport default Game;\n","import React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport Game, { GAME_STATE, IGameState } from \"./Game\";\nimport { IWordObject } from \"./Word\";\nimport confetti from \"canvas-confetti\";\n\nconst shootConfetti = () => {\n  function randomInRange(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n  }\n\n  confetti({\n    angle: randomInRange(55, 125),\n    spread: randomInRange(50, 70),\n    particleCount: randomInRange(50, 100),\n    origin: { y: 0.6 },\n  });\n};\n\nconst FPS = 30;\n\nconst WORDS = Lib();\n\nfunction App() {\n  const [gameLoopId, setGameLoopId] = useState<NodeJS.Timeout | null>(null);\n  const [state, setState] = useState<IGameState | null>(null);\n  const game = React.useMemo(() => Game({ WORDS }), []);\n  const handleKeyDown = React.useCallback(({ key, code }: KeyboardEvent) => {\n    const word = game.onKeydown({ key, code });\n    if (word) {\n      // console.log(\"hit\", word);\n      word.isKilled() && shootConfetti();\n    } else {\n      console.log(\"miss\");\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleKeyDown);\n    const tick = () => {\n      game.tick();\n      setState(game.getState());\n    };\n\n    tick();\n    const interval = setInterval(tick, 1000 / FPS);\n    setGameLoopId(interval);\n\n    return () => {\n      clearInterval(interval);\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, []);\n\n  // useEffect(() => {\n  //   console.log(\"state update\", state);\n  // }, [state]);\n\n  useEffect(() => {\n    if (state?.state === GAME_STATE.SCORE) {\n      console.log(\"SCORE SCREEN\");\n      gameLoopId && clearInterval(gameLoopId);\n      setGameLoopId(null);\n    } else if (state?.state === GAME_STATE.PLAY) {\n      console.log(\"PLAY SCREEN\");\n    }\n  }, [state?.state]);\n\n  const [toEnd, setToEnd] = React.useState(false);\n  const sample = (arr: any[]) => {\n    const len = arr == null ? 0 : arr.length;\n    return len ? arr[Math.floor(Math.random() * len)] : undefined;\n  };\n\n  const duration = `${1 + Math.random() * 1.5}s`;\n\n  return (\n    <div className=\"App\">\n      <div className=\"words\">\n        {/* {state?.words.map((word) => (\n          <Word key={\"id\" + String(word.id)} word={word} />\n        ))} */}\n        {state?.words.map((word) => {\n          const { duration } = word;\n          const _word = word.getWord();\n          const typed = _word.substr(0, word.getTyped());\n          const notTyped = _word.substr(word.getTyped());\n\n          return (\n            <div\n              key={word.id}\n              className={`word toEnd`}\n              style={{\n                left: word.pos + \"%\",\n                transitionDuration: `${duration}ms`,\n                animationDuration: `${duration}ms`,\n                background: notTyped.length === 0 ? \"green\" : undefined,\n              }}\n            >\n              <span style={{ color: \"orange\", fontWeight: \"bold\" }}>\n                {typed}\n              </span>\n              {notTyped}\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"player\"></div>\n      {state?.state === GAME_STATE.SCORE && state?.score ? (\n        <h1\n          style={{\n            position: \"absolute\",\n            top: \"50%\",\n            left: \"50%\",\n            textAlign: \"center\",\n            transform: \"translate(-50%, -50%)\",\n          }}\n        >\n          SCORE: {state.score}\n          <br />\n          TIME: {(state.game_duration / 1000).toFixed(2)} sec.\n        </h1>\n      ) : null}\n    </div>\n  );\n}\n\nfunction WordComponent({ word, key }: { word: IWordObject; key: string }) {\n  const { duration } = word;\n  const _word = word.getWord();\n  const typed = _word.substr(0, word.getTyped());\n  const notTyped = _word.substr(word.getTyped());\n\n  return (\n    <div\n      key={key}\n      className={`word toEnd`}\n      style={{\n        left: word.pos,\n        transitionDuration: `${duration}ms`,\n        animationDuration: `${duration}ms`,\n        background: notTyped.length === 0 ? \"green\" : undefined,\n      }}\n    >\n      <span style={{ color: \"orange\", fontWeight: \"bold\" }}>{typed}</span>\n      {notTyped}\n    </div>\n  );\n}\n\nfunction Lib() {\n  var lib = {\n    1: \"nil lib go pen var if add zsh run php bug fix api key add all id em erb rem px ux ui svg for box git xml rtc pre rgb hsl rel web js def moz end to dev css\".split(\n      \" \"\n    ),\n    2: \"void null code scss bash else push edge ruby pull tidy head body foot haml slim jade true html color top span left right save fork flex none bold auto href link size ease fill path rgba hsla from skew sort font size team sass hash json less attr text data\".split(\n      \" \"\n    ),\n    3: \"react ember event width height clone gulp concat fetch valid aside style elsif babel jquery param start assign posts logos chrome blogs block align xcode slack class agile xmlns origin comma scrum stroke scale false rails\".split(\n      \" \"\n    ),\n    4: \"inline method deploy target assign window grunt commit minify jekyll stylus article import tweets google opacity weight bottom scroll italic profile hidden github keytrap editor webkit string number integer decimal period jsconf\".split(\n      \" \"\n    ),\n    5: \"inherit function includes bourbon normalize angular explorer section ternary twitter overflow absolute postcss invalid viewbox content sublime session display background compile bracket backbone boolean codepen dreamhire contains standup\".split(\n      \" \"\n    ),\n    6: \"chriscoyier javascript cssdevconf customers autoprefixer stackoverflow visibility headphones underscore bootstrap csstricks typescript livescript customer settings semicolon attribute parenthesis markdown compiler responsive preprocessor webdesign developer development\".split(\n      \" \"\n    ),\n  };\n  return Object.values(lib).flat();\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}